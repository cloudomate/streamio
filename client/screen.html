<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Screen Stream</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            background: #0d1117;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            height: 100vh;
            display: flex;
            flex-direction: column;
        }
        .header {
            background: #161b22;
            padding: 8px 16px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            border-bottom: 1px solid #30363d;
        }
        .header h1 {
            color: #58a6ff;
            font-size: 16px;
            font-weight: 500;
        }
        .status {
            display: flex;
            align-items: center;
            gap: 8px;
            color: #8b949e;
            font-size: 13px;
        }
        .status-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: #f85149;
        }
        .status-dot.connected { background: #3fb950; }
        .video-container {
            flex: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            background: #000;
            position: relative;
            cursor: none;  /* Hide local cursor - remote cursor is visible in stream */
        }
        #video {
            max-width: 100%;
            max-height: 100%;
            background: #000;
            cursor: none;
        }
        .controls {
            background: #161b22;
            padding: 8px 16px;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 16px;
            border-top: 1px solid #30363d;
        }
        .controls button {
            background: #21262d;
            color: #c9d1d9;
            border: 1px solid #30363d;
            padding: 6px 12px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 12px;
        }
        .controls button:hover {
            background: #30363d;
        }
        .stats {
            color: #8b949e;
            font-family: monospace;
            font-size: 12px;
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>Screen Stream (VDI)</h1>
        <div class="status">
            <div class="status-dot" id="statusDot"></div>
            <span id="statusText">Connecting...</span>
        </div>
    </div>

    <div class="video-container" id="videoContainer">
        <video id="video" autoplay playsinline></video>
    </div>

    <div class="controls">
        <button onclick="toggleFullscreen()">Fullscreen</button>
        <button onclick="toggleAudio()" id="audioBtn">Unmute</button>
        <button onclick="toggleMic()" id="micBtn">Mic Off</button>
        <button onclick="reconnect()">Reconnect</button>
        <span class="stats" id="stats">--</span>
        <span class="stats" id="coords">--</span>
    </div>

    <script>
        const video = document.getElementById('video');
        const statusDot = document.getElementById('statusDot');
        const statusText = document.getElementById('statusText');
        const statsEl = document.getElementById('stats');
        const coordsEl = document.getElementById('coords');

        let ws = null;
        let pc = null;
        let connecting = false;

        function connect() {
            if (connecting || (ws && ws.readyState === WebSocket.OPEN)) {
                console.log('Already connected or connecting');
                return;
            }
            connecting = true;

            // Clean up existing connections
            if (pc) { pc.close(); pc = null; }
            if (ws) { ws.close(); ws = null; }

            const protocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
            ws = new WebSocket(`${protocol}//${location.host}/ws`);

            ws.onopen = () => {
                console.log('WebSocket connected');
                statusText.textContent = 'Connected';
                connecting = false;
            };

            ws.onclose = () => {
                console.log('WebSocket closed');
                statusDot.classList.remove('connected');
                statusText.textContent = 'Disconnected';
                connecting = false;
                if (pc) { pc.close(); pc = null; }
                // Only reconnect if not manually disconnected
                setTimeout(connect, 3000);
            };

            ws.onerror = (err) => {
                console.error('WebSocket error:', err);
                connecting = false;
            };

            ws.onmessage = async (event) => {
                const msg = JSON.parse(event.data);
                console.log('Received:', msg.type);

                if (msg.type === 'offer') {
                    await handleOffer(msg.sdp);
                } else if (msg.type === 'ice') {
                    await handleIce(msg);
                }
            };
        }

        let localStream = null;

        async function handleOffer(sdp) {
            pc = new RTCPeerConnection({
                iceServers: [{ urls: 'stun:stun.l.google.com:19302' }]
            });

            pc.ontrack = (event) => {
                console.log('Track received:', event.track.kind);
                if (event.track.kind === 'video') {
                    video.srcObject = event.streams[0];
                    // Try to play, may need user interaction for audio
                    video.play().catch(e => {
                        console.log('Autoplay blocked, click to unmute');
                        video.muted = true;
                        video.play();
                    });
                } else if (event.track.kind === 'audio') {
                    console.log('Remote audio track received');
                    // Audio is part of the same stream as video
                }
            };

            // Request microphone access and add to connection
            try {
                localStream = await navigator.mediaDevices.getUserMedia({ audio: true });
                localStream.getTracks().forEach(track => {
                    pc.addTrack(track, localStream);
                    console.log('Added local audio track:', track.kind);
                });
            } catch (e) {
                console.log('Microphone access denied or not available:', e.message);
            }

            pc.onicecandidate = (event) => {
                if (event.candidate) {
                    ws.send(JSON.stringify({
                        type: 'ice',
                        candidate: event.candidate.candidate,
                        sdp_mid: event.candidate.sdpMid,
                        sdp_m_line_index: event.candidate.sdpMLineIndex
                    }));
                }
            };

            pc.onconnectionstatechange = () => {
                console.log('Connection state:', pc.connectionState);
                if (pc.connectionState === 'connected') {
                    statusDot.classList.add('connected');
                    statusText.textContent = 'Streaming';
                }
            };

            await pc.setRemoteDescription({ type: 'offer', sdp });
            const answer = await pc.createAnswer();
            await pc.setLocalDescription(answer);

            ws.send(JSON.stringify({ type: 'answer', sdp: answer.sdp }));
        }

        async function handleIce(msg) {
            if (pc && msg.candidate) {
                try {
                    await pc.addIceCandidate({
                        candidate: msg.candidate,
                        sdpMid: msg.sdp_mid,
                        sdpMLineIndex: msg.sdp_m_line_index
                    });
                } catch (e) {
                    console.error('ICE error:', e);
                }
            }
        }

        function toggleFullscreen() {
            if (document.fullscreenElement) {
                document.exitFullscreen();
            } else {
                video.requestFullscreen();
            }
        }

        function toggleAudio() {
            video.muted = !video.muted;
            document.getElementById('audioBtn').textContent = video.muted ? 'Unmute' : 'Mute';
        }

        function toggleMic() {
            if (localStream) {
                const audioTrack = localStream.getAudioTracks()[0];
                if (audioTrack) {
                    audioTrack.enabled = !audioTrack.enabled;
                    document.getElementById('micBtn').textContent = audioTrack.enabled ? 'Mic Off' : 'Mic On';
                }
            }
        }

        function reconnect() {
            connecting = false;
            if (ws) ws.close();
            if (pc) pc.close();
            ws = null;
            pc = null;
            setTimeout(connect, 500);
        }

        // Input handling - send mouse/keyboard to server
        function sendInput(event) {
            if (ws && ws.readyState === WebSocket.OPEN) {
                ws.send(JSON.stringify(event));
            }
        }

        // Get coordinates relative to actual video content
        // Handles letterboxing and aspect ratio differences
        // GStreamer avfvideosrc captures at point resolution, so no DPR adjustment needed
        function getVideoCoords(e) {
            const rect = video.getBoundingClientRect();
            const videoWidth = video.videoWidth || 1920;
            const videoHeight = video.videoHeight || 1080;

            // Calculate actual video display size (accounting for aspect ratio)
            const videoAspect = videoWidth / videoHeight;
            const rectAspect = rect.width / rect.height;

            let displayWidth, displayHeight, offsetX, offsetY;
            if (rectAspect > videoAspect) {
                // Letterboxed horizontally (black bars on sides)
                displayHeight = rect.height;
                displayWidth = rect.height * videoAspect;
                offsetX = (rect.width - displayWidth) / 2;
                offsetY = 0;
            } else {
                // Letterboxed vertically (black bars on top/bottom)
                displayWidth = rect.width;
                displayHeight = rect.width / videoAspect;
                offsetX = 0;
                offsetY = (rect.height - displayHeight) / 2;
            }

            // Calculate position within the actual video content
            const relX = e.clientX - rect.left - offsetX;
            const relY = e.clientY - rect.top - offsetY;

            // Check if click is within video content area
            if (relX < 0 || relX > displayWidth || relY < 0 || relY > displayHeight) {
                return null;  // Click outside video content
            }

            // Scale to video resolution (which is in screen points on macOS)
            const scaleX = videoWidth / displayWidth;
            const scaleY = videoHeight / displayHeight;

            return {
                x: Math.round(relX * scaleX),
                y: Math.round(relY * scaleY)
            };
        }

        // Mouse events - use video container for better event capture
        const videoContainer = document.getElementById('videoContainer');

        videoContainer.addEventListener('mousedown', (e) => {
            const coords = getVideoCoords(e);
            if (coords) {
                sendInput({ type: 'mouse_down', button: e.button, x: coords.x, y: coords.y });
            }
            e.preventDefault();
        });

        videoContainer.addEventListener('mouseup', (e) => {
            const coords = getVideoCoords(e);
            if (coords) {
                sendInput({ type: 'mouse_up', button: e.button, x: coords.x, y: coords.y });
            }
            e.preventDefault();
        });

        videoContainer.addEventListener('mousemove', (e) => {
            const coords = getVideoCoords(e);
            if (coords) {
                sendInput({ type: 'mouse_move', x: coords.x, y: coords.y });
                // Show debug info
                coordsEl.textContent = `${coords.x},${coords.y} | vid:${video.videoWidth}x${video.videoHeight}`;
            }
        });

        video.addEventListener('wheel', (e) => {
            sendInput({ type: 'scroll', dx: e.deltaX, dy: e.deltaY });
            e.preventDefault();
        }, { passive: false });

        video.addEventListener('contextmenu', (e) => e.preventDefault());

        // Keyboard events - capture on document level for reliability
        video.tabIndex = 0; // Make video focusable

        // Auto-focus video when clicking
        video.addEventListener('click', () => video.focus());

        // Capture keyboard globally when video has focus or mouse is over it
        let videoHasFocus = false;

        video.addEventListener('mouseenter', () => { videoHasFocus = true; video.focus(); });
        video.addEventListener('mouseleave', () => { videoHasFocus = false; });
        video.addEventListener('focus', () => { videoHasFocus = true; });
        video.addEventListener('blur', () => { videoHasFocus = false; });

        document.addEventListener('keydown', (e) => {
            if (videoHasFocus) {
                sendInput({ type: 'key_down', key: e.key, code: e.code, modifiers: getModifiers(e) });
                e.preventDefault();
            }
        });

        document.addEventListener('keyup', (e) => {
            if (videoHasFocus) {
                sendInput({ type: 'key_up', key: e.key, code: e.code, modifiers: getModifiers(e) });
                e.preventDefault();
            }
        });

        function getModifiers(e) {
            return {
                shift: e.shiftKey,
                ctrl: e.ctrlKey,
                alt: e.altKey,
                meta: e.metaKey
            };
        }

        // Stats
        setInterval(() => {
            if (pc) {
                pc.getStats().then(stats => {
                    stats.forEach(report => {
                        if (report.type === 'inbound-rtp' && report.kind === 'video') {
                            const fps = report.framesPerSecond || 0;
                            statsEl.textContent = `${fps.toFixed(0)} fps | ${report.framesDecoded || 0} frames`;
                        }
                    });
                });
            }
        }, 1000);

        connect();
    </script>
</body>
</html>
